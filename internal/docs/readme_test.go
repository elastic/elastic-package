// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

package docs

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/elastic/elastic-package/internal/packages"
)

func TestGenerateReadme(t *testing.T) {
	cases := []struct {
		title                  string
		filename               string
		readmeTemplateContents string
		expected               string
	}{
		{
			title:    "Pure markdown",
			filename: "README.md",
			readmeTemplateContents: `
# README
Introduction to the package`,
			expected: `
# README
Introduction to the package`,
		},
		{
			title:    "Generated headers",
			filename: "README.md",
			readmeTemplateContents: `
{{- generatedHeader }}
# README
Introduction to the package`,
			expected: `<!-- NOTICE: Do not edit this file manually.-->
<!-- This file is automatically generated by Elastic Package -->
# README
Introduction to the package`,
		},
		{
			title:                  "Static README",
			filename:               "README.md",
			readmeTemplateContents: "",
			expected:               "",
		},
	}
	for _, c := range cases {
		t.Run(c.title, func(t *testing.T) {
			dir := t.TempDir()
			createReadmeTemplateFile(t, dir, c.readmeTemplateContents)

			root, err := os.OpenRoot(dir)
			require.NoError(t, err)
			t.Cleanup(func() { root.Close() })

			rendered, isTemplate, err := GenerateReadme(root, c.filename, "", dir)
			require.NoError(t, err)

			if c.readmeTemplateContents != "" {
				renderedString := string(rendered)
				assert.True(t, isTemplate)
				assert.Equal(t, c.expected, renderedString)
			} else {
				assert.False(t, isTemplate)
				assert.Nil(t, rendered)
			}
		})
	}
}

func TestRenderReadmeWithLinks(t *testing.T) {
	minimumLinksMap := newEmptyLinkMap()
	minimumLinksMap.Add("foo", "http://www.example.com/bar")

	cases := []struct {
		title                  string
		packageRoot            string
		templatePath           string
		readmeTemplateContents string
		linksMap               linkMap
		expected               string
	}{
		{
			title:        "Readme with url function",
			packageRoot:  t.TempDir(),
			templatePath: "_dev/build/docs/README.md",
			readmeTemplateContents: `
{{- generatedHeader }}

# README
Introduction to the package
{{ url "foo" }}
{{ url "foo" "Example" }}`,
			expected: `<!-- NOTICE: Do not edit this file manually.-->
<!-- This file is automatically generated by Elastic Package -->

# README
Introduction to the package
http://www.example.com/bar
[Example](http://www.example.com/bar)`,
			linksMap: minimumLinksMap,
		},
	}

	for _, c := range cases {
		t.Run(c.title, func(t *testing.T) {
			filename := filepath.Base(c.templatePath)
			templatePath := filepath.Join(c.packageRoot, c.templatePath)

			createReadmeTemplateFile(t, c.packageRoot, c.readmeTemplateContents)

			root, err := os.OpenRoot(c.packageRoot)
			require.NoError(t, err)
			t.Cleanup(func() { root.Close() })

			rendered, err := renderReadme(root, filename, c.packageRoot, templatePath, c.linksMap)
			require.NoError(t, err)

			renderedString := string(rendered)
			assert.Equal(t, c.expected, renderedString)
		})
	}
}

func TestRenderReadmeWithSampleEvent(t *testing.T) {
	cases := []struct {
		title                   string
		packageRoot             string
		templatePath            string
		dataStreamName          string
		readmeTemplateContents  string
		sampleEventJsonContents string
		expected                string
	}{
		{
			title:        "README with sample event",
			packageRoot:  t.TempDir(),
			templatePath: "_dev/build/docs/README.md",
			readmeTemplateContents: `
{{- generatedHeader }}
# README
Introduction to the package
{{ event "example" }}`,
			expected: `<!-- NOTICE: Do not edit this file manually.-->
<!-- This file is automatically generated by Elastic Package -->
# README
Introduction to the package
An example event for ` + "`example`" + ` looks as following:

` + "```json" + `
{
    "id": "event1"
}
` + "```",
			dataStreamName:          "example",
			sampleEventJsonContents: `{"id": "event1"}`,
		},
	}

	linksMap := newEmptyLinkMap()
	for _, c := range cases {
		t.Run(c.title, func(t *testing.T) {
			filename := filepath.Base(c.templatePath)
			templatePath := filepath.Join(c.packageRoot, c.templatePath)

			createReadmeTemplateFile(t, c.packageRoot, c.readmeTemplateContents)
			createSampleEventFile(t, c.packageRoot, c.dataStreamName, c.sampleEventJsonContents)
			createManifestFile(t, c.packageRoot)

			root, err := os.OpenRoot(c.packageRoot)
			require.NoError(t, err)
			t.Cleanup(func() { root.Close() })

			rendered, err := renderReadme(root, filename, c.packageRoot, templatePath, linksMap)
			require.NoError(t, err)

			renderedString := string(rendered)
			assert.Equal(t, c.expected, renderedString)
		})
	}
}

var renderCases = []struct {
	title                  string
	templatePath           string
	dataStreamName         string
	readmeTemplateContents string
	fieldsContents         string
	expected               string
}{
	{
		title:        "README fields from package",
		templatePath: "_dev/build/docs/README.md",
		readmeTemplateContents: `
{{- generatedHeader }}
# README
Introduction to the package
{{ fields }}`,
		expected: `<!-- NOTICE: Do not edit this file manually.-->
<!-- This file is automatically generated by Elastic Package -->
# README
Introduction to the package
**Exported fields**

| Field | Description | Type |
|---|---|---|
| data_stream.type | Data stream type package. | constant_keyword |
`,
		dataStreamName: "",
		fieldsContents: `
- name: data_stream.type
  type: constant_keyword
  description: Data stream type package.`,
	},
	{
		title:        "README with one field",
		templatePath: "_dev/build/docs/README.md",
		readmeTemplateContents: `# README
Introduction to the package
{{ fields "example" }}`,
		expected: `# README
Introduction to the package
**Exported fields**

| Field | Description | Type |
|---|---|---|
| data_stream.type | Data stream type. | constant_keyword |
`,
		dataStreamName: "example",
		fieldsContents: `
- name: data_stream.type
  type: constant_keyword
  description: Data stream type.`,
	},
	{
		title:        "README with group fields",
		templatePath: "_dev/build/docs/README.md",
		readmeTemplateContents: `
# README
Introduction to the package
{{ fields "example" }}`,
		expected: `
# README
Introduction to the package
**Exported fields**

| Field | Description | Type |
|---|---|---|
| dns.answers | An array containing an object for each answer section returned by the server. The main keys that should be present in these objects are defined by ECS. Records that have more information may contain more keys than what ECS defines. Not all DNS data sources give all details about DNS answers. At minimum, answer objects must contain the ` + "`data`" + ` key. If more information is available, map as much of it to ECS as possible, and add any additional fields to the answer objects as custom fields. | group |
| dns.answers.name | The domain name to which this resource record pertains. If a chain of CNAME is being resolved, each answer's ` + "`name`" + ` should be the one that corresponds with the answer's ` + "`data`" + `. It should not simply be the original ` + "`question.name`" + ` repeated. | keyword |
`,
		dataStreamName: "example",
		fieldsContents: `
- name: emptygroup
  type: group
- external: ecs
  name: dns.answers
  type: group
- external: ecs
  name: dns.answers.name
`,
	},
	{
		title:        "README no fields",
		templatePath: "_dev/build/docs/README.md",
		readmeTemplateContents: `
{{- generatedHeader }}
# README
Introduction to the package
{{ fields "notexist" }}`,
		expected: `<!-- NOTICE: Do not edit this file manually.-->
<!-- This file is automatically generated by Elastic Package -->
# README
Introduction to the package
**Exported fields**

(no fields available)
`,
		dataStreamName: "example",
		fieldsContents: "",
	},
}

func TestRenderReadmeWithFields(t *testing.T) {
	linksMap := newEmptyLinkMap()
	for _, c := range renderCases {
		t.Run(c.title, func(t *testing.T) {
			packageRoot := t.TempDir()
			filename := filepath.Base(c.templatePath)
			templatePath := filepath.Join(packageRoot, c.templatePath)

			createManifestFile(t, packageRoot)
			createBuildFile(t, packageRoot)
			createReadmeTemplateFile(t, packageRoot, c.readmeTemplateContents)
			createFieldsFile(t, packageRoot, c.dataStreamName, c.fieldsContents)

			root, err := os.OpenRoot(packageRoot)
			require.NoError(t, err)
			t.Cleanup(func() { root.Close() })

			rendered, err := renderReadme(root, filename, packageRoot, templatePath, linksMap)
			require.NoError(t, err)

			renderedString := string(rendered)
			assert.Equal(t, c.expected, renderedString)
		})
	}
}

func TestUpdateReadmeWithFields(t *testing.T) {
	for _, c := range renderCases {
		t.Run(c.title, func(t *testing.T) {
			packageRoot := t.TempDir()
			filename := filepath.Base(c.templatePath)

			createManifestFile(t, packageRoot)
			createBuildFile(t, packageRoot)
			createReadmeTemplateFile(t, packageRoot, c.readmeTemplateContents)
			createFieldsFile(t, packageRoot, c.dataStreamName, c.fieldsContents)

			buildPackageRoot := t.TempDir()
			createManifestFile(t, buildPackageRoot)

			root, err := os.OpenRoot(packageRoot)
			require.NoError(t, err)
			t.Cleanup(func() { root.Close() })

			readmePath, err := updateReadme(root, filename, "", packageRoot, buildPackageRoot)
			require.NoError(t, err)
			require.NotEmpty(t, readmePath)
			d, err := os.ReadFile(readmePath)
			require.NoError(t, err)
			assert.Equal(t, string(c.expected), string(d))

			builtReadmePath, err := filepath.Rel(packageRoot, readmePath)
			require.NoError(t, err)
			builtReadmePath = filepath.Join(buildPackageRoot, builtReadmePath)
			d, err = os.ReadFile(builtReadmePath)
			require.NoError(t, err)
			assert.Equal(t, string(c.expected), string(d))
		})
	}
}

func createReadmeTemplateFile(t *testing.T, packageRoot, contents string) {
	t.Helper()
	docsFolder := createDocsFolder(t, packageRoot)
	if contents != "" {
		readmeFile := filepath.Join(docsFolder, "README.md")
		err := os.WriteFile(readmeFile, []byte(contents), 0o644)
		require.NoError(t, err)
	}
}

func createDocsFolder(t *testing.T, packageRoot string) string {
	t.Helper()
	docsFolder := filepath.Join(packageRoot, "_dev", "build", "docs")
	err := os.MkdirAll(docsFolder, 0o755)
	require.NoError(t, err)
	return docsFolder
}

func createSampleEventFile(t *testing.T, packageRoot, dataStreamName, contents string) {
	t.Helper()
	dataStreamFolder := createDataStreamFolder(t, packageRoot, dataStreamName)

	sampleEventFile := filepath.Join(dataStreamFolder, sampleEventFile)
	err := os.WriteFile(sampleEventFile, []byte(contents), 0o644)
	require.NoError(t, err)
}

func createManifestFile(t *testing.T, packageRoot string) {
	t.Helper()
	// Minimal content needed to render readme.
	manifest := `format_version: 2.10.0
type: integration
version: 1.0.0
`
	manifestFile := filepath.Join(packageRoot, packages.PackageManifestFile)
	err := os.WriteFile(manifestFile, []byte(manifest), 0o644)
	require.NoError(t, err)
}

func createDataStreamFolder(t *testing.T, packageRoot, dataStreamName string) string {
	t.Helper()
	if dataStreamName == "" {
		return ""
	}

	dataStreamFolder := filepath.Join(packageRoot, "data_stream", dataStreamName)
	err := os.MkdirAll(dataStreamFolder, 0o755)
	require.NoError(t, err)

	return dataStreamFolder
}

func createFieldsFile(t *testing.T, packageRoot, dataStreamName, contents string) {
	t.Helper()
	fieldsFolder := createFieldsFolder(t, packageRoot, dataStreamName)
	fieldsFile := filepath.Join(fieldsFolder, "fields.yml")

	err := os.WriteFile(fieldsFile, []byte(contents), 0o644)
	require.NoError(t, err)
}

func createFieldsFolder(t *testing.T, packageRoot, dataStreamName string) string {
	t.Helper()
	fieldsFolder := packageRoot
	if dataStreamName != "" {
		fieldsFolder = filepath.Join(fieldsFolder, "data_stream", dataStreamName)
	}
	fieldsFolder = filepath.Join(fieldsFolder, "fields")

	err := os.MkdirAll(fieldsFolder, 0o755)
	require.NoError(t, err)

	return fieldsFolder
}

func createBuildFile(t *testing.T, packageRoot string) {
	t.Helper()
	buildDir := filepath.Join(packageRoot, "_dev", "build")
	err := os.MkdirAll(buildDir, 0o755)
	require.NoError(t, err)

	content := `dependencies:
  ecs:
    reference: git@8.1
`
	buildFile := filepath.Join(buildDir, "build.yml")
	err = os.WriteFile(buildFile, []byte(content), 0o644)
	require.NoError(t, err)
}
