// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

package docagent

import (
	"errors"
	"fmt"
	"strings"

	"github.com/elastic/elastic-package/internal/docs"
	"github.com/elastic/elastic-package/internal/llmagent/ui"
	"github.com/elastic/elastic-package/internal/tui"
)

const (
	ActionAccept  = "Accept and finalize"
	ActionRequest = "Request changes"
	ActionCancel  = "Cancel"

	ActionTryAgain = "Try again"
	ActionExit     = "Exit"
)

// ActionResult holds the result of a user action
type ActionResult struct {
	NewPrompt      string
	ShouldContinue bool // true = continue loop, false = exit
	Err            error
}

// getUserAction prompts the user for their next action
func (d *DocumentationAgent) getUserAction() (string, error) {
	selectPrompt := tui.NewSelect("What would you like to do?", []string{
		ActionAccept,
		ActionRequest,
		ActionCancel,
	}, ActionAccept)

	var action string
	err := tui.AskOne(selectPrompt, &action)
	if err != nil {
		return "", fmt.Errorf("prompt failed: %w", err)
	}

	return action, nil
}

// displayReadme shows documentation content in a browser or terminal UI
func (d *DocumentationAgent) displayReadme() error {
	sourceContent, err := d.readCurrentReadme()
	if err != nil || sourceContent == "" {
		fmt.Printf("\n‚ö†Ô∏è  %s file exists but could not be read or is empty\n", d.targetDocFile)
		return fmt.Errorf("could not read file for rendering: %w", err)
	}

	// Try to render the content
	renderedContent, shouldBeRendered, err := docs.GenerateReadme(d.targetDocFile, "", d.packageRoot, d.packageRoot)
	if err != nil || !shouldBeRendered {
		fmt.Printf("\n‚ö†Ô∏è  The generated %s could not be rendered.\n", d.targetDocFile)
		fmt.Println("It's recommended that you do not accept this version (ask for revisions or cancel).")
		return fmt.Errorf("could not render readme: %w", err)
	}

	// Show the processed/rendered content
	processedContentStr := string(renderedContent)
	fmt.Printf("üìä Processed %s stats: %d characters, %d lines\n", d.targetDocFile, len(processedContentStr), strings.Count(processedContentStr, "\n")+1)

	// Try to open in browser first
	if ui.TryBrowserPreview(processedContentStr) {
		fmt.Println("üåê Opening documentation preview in your web browser...")
		fmt.Println("üí° Return here to accept or request changes.")
	} else {
		// Fallback to terminal display if browser preview fails
		title := fmt.Sprintf("üìÑ Processed %s (as generated by elastic-package build)", d.targetDocFile)
		if err := tui.ShowContent(title, processedContentStr); err != nil {
			// Fallback to simple print if viewer fails
			fmt.Printf("\n%s:\n", title)
			fmt.Println(strings.Repeat("=", 70))
			fmt.Println(processedContentStr)
			fmt.Println(strings.Repeat("=", 70))
		}
	}
	return nil
}

// handleReadmeUpdate checks if documentation file was updated and reports the result
func (d *DocumentationAgent) handleReadmeUpdate() (bool, error) {
	readmeUpdated, err := d.isReadmeUpdated()
	if err != nil {
		return false, err
	}
	if !readmeUpdated {
		return false, nil
	}

	// An empty file is not considered updated
	content, err := d.readCurrentReadme()
	if err != nil || content == "" {
		if err == nil {
			err = fmt.Errorf("readme file empty")
		}
		return false, err
	}

	fmt.Printf("‚úÖ Documentation update completed! (%d characters written to %s)\n", len(content), d.targetDocFile)
	return true, nil
}

// handleInteractiveError handles error responses in interactive mode
func (d *DocumentationAgent) handleInteractiveError() (string, bool, error) {
	fmt.Println("\n‚ùå Error detected in LLM response.")

	errorPrompt := tui.NewSelect("What would you like to do?", []string{
		ActionTryAgain,
		ActionExit,
	}, ActionTryAgain)

	var errorAction string
	err := tui.AskOne(errorPrompt, &errorAction)
	if err != nil {
		return "", false, fmt.Errorf("prompt failed: %w", err)
	}

	if errorAction == ActionExit {
		fmt.Println("‚ö†Ô∏è  Exiting due to LLM error.")
		return "", false, nil
	}

	// Continue with retry prompt
	promptCtx := d.createPromptContext(d.manifest, "The previous attempt encountered an error. Please try a different approach to analyze the package and update the documentation.")
	prompt := d.buildPrompt(PromptTypeRevision, promptCtx)
	return prompt, true, nil
}

// handleUserAction processes the user's chosen action
func (d *DocumentationAgent) handleUserAction(action string, readmeUpdated bool) ActionResult {
	switch action {
	case ActionAccept:
		return d.handleAcceptAction(readmeUpdated)
	case ActionRequest:
		return d.handleRequestChanges()
	case ActionCancel:
		fmt.Println("‚ùå Documentation update cancelled.")
		d.restoreOriginalReadme()
		return ActionResult{"", false, nil}
	default:
		return ActionResult{"", false, fmt.Errorf("unknown action: %s", action)}
	}
}

// handleAcceptAction handles the "Accept and finalize" action
func (d *DocumentationAgent) handleAcceptAction(readmeUpdated bool) ActionResult {
	if readmeUpdated {
		// Validate preserved sections if we had original content
		if d.originalReadmeContent != nil {
			if newContent, err := d.readCurrentReadme(); err == nil {
				preserved := d.arePreservedSectionsKept(*d.originalReadmeContent, newContent)
				if !preserved {
					fmt.Println("‚ö†Ô∏è  Warning: Some human-edited sections may not have been preserved")
					fmt.Println("   Please review the documentation to ensure important content wasn't lost.")
					return ActionResult{"", false, fmt.Errorf("human-edited sections not preserved")}
				}
			}
		}

		fmt.Println("‚úÖ Documentation update completed!")
		return ActionResult{"", false, nil}
	}

	// Documentation file wasn't updated - ask user what to do
	continuePrompt := tui.NewSelect(fmt.Sprintf("%s file wasn't updated. What would you like to do?", d.targetDocFile), []string{
		ActionTryAgain,
		ActionExit,
	}, ActionTryAgain)

	var continueChoice string
	err := tui.AskOne(continuePrompt, &continueChoice)
	if err != nil {
		return ActionResult{"", false, fmt.Errorf("prompt failed: %w", err)}
	}

	if continueChoice == ActionExit {
		fmt.Printf("‚ö†Ô∏è  Exiting without creating %s file.\n", d.targetDocFile)
		d.restoreOriginalReadme()
		return ActionResult{"", false, nil}
	}

	fmt.Printf("üîÑ Trying again to create %s...\n", d.targetDocFile)
	promptCtx := d.createPromptContext(d.manifest, fmt.Sprintf("You haven't written a %s file yet. Please write the %s file in the _dev/build/docs/ directory based on your analysis.", d.targetDocFile, d.targetDocFile))
	newPrompt := d.buildPrompt(PromptTypeRevision, promptCtx)
	return ActionResult{newPrompt, true, nil}
}

// handleRequestChanges handles the "Request changes" action
func (d *DocumentationAgent) handleRequestChanges() ActionResult {
	changes, err := tui.AskTextArea("What changes would you like to make to the documentation?")
	if err != nil {
		// Check if user cancelled
		if errors.Is(err, tui.ErrCancelled) {
			fmt.Println("‚ö†Ô∏è  Changes request cancelled.")
			return ActionResult{"", true, nil} // Continue the loop
		}
		return ActionResult{"", false, fmt.Errorf("prompt failed: %w", err)}
	}

	// Check if no changes were provided
	if strings.TrimSpace(changes) == "" {
		fmt.Println("‚ö†Ô∏è  No changes specified. Please try again.")
		return ActionResult{"", true, nil} // Continue the loop
	}
	promptCtx := d.createPromptContext(d.manifest, changes)
	newPrompt := d.buildPrompt(PromptTypeRevision, promptCtx)
	return ActionResult{newPrompt, true, nil}
}
